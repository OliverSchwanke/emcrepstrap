#! /usr/bin/env python
"""
Fill is a script to fill the slices of a gcode file.

To run fill, install python 2.x on your machine, which is avaliable from http://www.python.org/download/

To use the preferences dialog you'll also need Tkinter, which probably came with the python installation.  If it did not, look for it at:
www.tcl.tk/software/tcltk/

To export a GNU Triangulated Surface file from Art of Illusion, you can use the Export GNU Triangulated Surface script at:
http://members.axion.net/~enrique/Export%20GNU%20Triangulated%20Surface.bsh

To bring it into Art of Illusion, drop it into the folder ArtOfIllusion/Scripts/Tools/.

The GNU Triangulated Surface format is supported by Mesh Viewer, and it is described at:
http://gts.sourceforge.net/reference/gts-surfaces.html#GTS-SURFACE-WRITE

To turn an STL file into filled gcode, first import the file using the STL import plugin in the import submenu of the file menu of Art of Illusion.
Then from the Scripts submenu in the Tools menu, choose Skeinforge and select the imported STL shape.  In the Fill radio button group,
choose Slice and click the 'Export Selected' checkbox.  Set the parameters and click OK.  Then type 'python fill.py' in a shell in the folder
which fill is in and when the dialog pops up, then click 'Fill', choose the file which you exported in
Export GNU Triangulated Surface and the filled file will be saved with the suffix '_fill'.

To write documentation for this program, open a shell in the fill.py directory, then type 'pydoc -w fill', then open 'fill.html' in a browser
or click on the '?' button in the dialog.  To use other functions of fill, type 'python' in a shell to run the python interpreter, then type 'import fill'
to import this program.

The computation intensive python modules will use psyco if it is available and run about twice as fast.  Psyco is described at:
http://psyco.sourceforge.net/index.html

The psyco download page is:
http://psyco.sourceforge.net/download.html

The following examples fillet the files Hollow Square.gcode & Hollow Square.gts.  The examples are run in a terminal in the folder which contains
Hollow Square.gcode, Hollow Square.gts and fill.py.  The preferences can be set in the dialog or by changing the preferences file 'fill.csv' with a text editor
or a spreadsheet program set to separate tabs.


> pydoc -w fill
wrote fill.html


> python fill.py
This brings up the dialog, after clicking 'Fill', the following is printed:
File Hollow Square.gts is being chain filled.
The filled file is saved as Hollow Square_fill.gcode


>python
Python 2.5.1 (r251:54863, Sep 22 2007, 01:43:31)
[GCC 4.2.1 (SUSE Linux)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import fill
>>> fill.main()
File Hollow Square.gts is being filled.
The filled file is saved as Hollow Square_fill.gcode
It took 3 seconds to fill the file.


>>> fill.fillChainFile()
File Hollow Square.gts is being filled.
The filled file is saved as Hollow Square_fill.gcode
It took 3 seconds to fill the file.


>>> fill.fillFile()
File Hollow Square.gcode is being filled.
The filled file is saved as Hollow Square_fill.gcode
It took 3 seconds to fill the file.


>>> fill.getFillChainGcode("
( GCode generated by May 8, 2008 slice.py )
( Extruder Initialization )
..
many lines of gcode
..
")


>>> fill.getFillGcode("
( GCode generated by May 8, 2008 slice.py )
( Extruder Initialization )
..
many lines of gcode
..
")
"""

try:
	import psyco
	psyco.full()
except:
	pass
from vec3 import Vec3
import cStringIO
import euclidean
import gcodec
import intercircle
import math
import preferences
import slice
import sys
import time
import vectorwrite


__author__ = "Enrique Perez (perez_enrique@yahoo.com)"
__date__ = "$Date: 2008/28/04 $"
__license__ = "GPL 3.0"

#infill first
#one direction for while, split to weave, hex fill, loop inside sparse fill or run along sparse infill
#go from closest out to segment length
#transform, variable precision
#fillet should have just amount a choice is unneeded, stack, raft, export plugin
#custom inclined plane, inclined plane from model, screw, fillet travel as well maybe
#later addAroundClosest around arounds
#much afterwards make congajure multistep view, maybe simplify paths on top of loops; why?; actually I think we're already doing this
#maybe bridge supports although staggered spans are probably better
def addAroundClosest( arounds, layerExtrusionWidth, paths, removedEndpoint ):
	"Add the closest removed endpoint to the path, with minimal twisting."
	lessThanHalfInsetSquared = 0.2 * layerExtrusionWidth * layerExtrusionWidth #later maybe use layerFillInset
	removedEndpointPoint = removedEndpoint.point
	closestDistanceSquared = 999999999999999999.0
	closestPathIndex = None
	shortestPathLength = 999999999999999999.0
	for pathIndex in range( len( paths ) ):
		path = paths[ pathIndex ]
		for pointIndex in range( len( path ) ):
			point = path[ pointIndex ]
			distanceSquared = point.distance2( removedEndpointPoint )
			if distanceSquared < closestDistanceSquared:
				closestDistanceSquared = distanceSquared
				closestPathIndex = pathIndex
	if closestPathIndex == None:
		return
	closestPath = paths[ closestPathIndex ]
	if closestDistanceSquared < lessThanHalfInsetSquared:
		return
	closestPointIndex = getWithLeastLength( closestPath, removedEndpointPoint )
	if closestPointIndex == 0 or closestPointIndex == len( closestPath ):
		closestPath.insert( closestPointIndex, removedEndpointPoint )
		return
	otherPaths = paths[ 0 : closestPathIndex ] + paths[ closestPathIndex + 1 : len( paths ) ]
	if not isIntersectingLoopPathList( arounds, otherPaths, removedEndpointPoint, closestPath[ closestPointIndex - 1 ] ):
		if not isIntersectingLoopPathList( arounds, otherPaths, removedEndpointPoint, closestPath[ closestPointIndex ] ):
			closestPath.insert( closestPointIndex, removedEndpointPoint )

	"""
	removedSegment = removedEndpoint.otherEndpoint.point.minus( removedEndpointPoint )
	removedSegmentLength = removedSegment.length()
#	if removedSegmentLength < layerExtrusionWidth:
#		return
	beforePoint = closestPath[ closestPointIndex - 1 ]
	afterPoint = closestPath[ closestPointIndex + 1 ]
	segment = afterPoint.minus( beforePoint )
	segmentLength = segment.length()
	segment.normalize()
	if segmentLength < 8.0 * layerExtrusionWidth:
		return
	if removedSegmentLength > 0.8 * segmentLength:
		return
	afterAlongLength = 0.5 * segmentLength
	afterAlong = segment.times( afterAlongLength )
	afterBetween = beforePoint.plus( afterAlong )
	afterConcatenation = closestPath[ : ]
	afterConcatenation.insert( closestPointIndex + 1, afterBetween )
	afterConcatenationLength = euclidean.getPathLength( afterConcatenation )
	beforeConcatenation = closestPath[ : ]
	beforeConcatenation.insert( closestPointIndex, afterBetween )
	beforeConcatenationLength = euclidean.getPathLength( beforeConcatenation )
	return
	if afterConcatenationLength < beforeConcatenationLength:
#		afterAlongLength = 0.5 * segmentLength
		afterAlongLength = 0.3 * segmentLength
		afterAlong = segment.times( afterAlongLength )
		afterBetween = beforePoint.plus( afterAlong )
		closestPath.insert( closestPointIndex + 1, afterBetween )
		return
	afterAlongLength = 0.7 * segmentLength
	afterAlong = segment.times( afterAlongLength )
	afterBetween = beforePoint.plus( afterAlong )
	closestPath.insert( closestPointIndex, afterBetween )
	afterDistance = afterPoint.distance( removedEndpointPoint )
	beforeDistance = beforePoint.distance( removedEndpointPoint )
	if afterDistance < beforeDistance:
		afterAlong = segment.times( removedSegmentLength )
		afterBetween = afterPoint.minus( afterAlong )
#		closestPath.insert( closestPointIndex, afterBetween )
		return
	beforePoint = closestPath[ closestPointIndex - 1 ]
	centerPoint = removedEndpointPoint
	afterPoint = closestPath[ closestPointIndex + 1 ]
	beforeSegment = beforePoint.minus( centerPoint )
	beforeSegmentLength = beforeSegment.length()
	beforeSegment.normalize()
	afterSegment = afterPoint.minus( centerPoint )
	afterSegmentLength = afterSegment.length()
	afterSegment.normalize()
	beforePlaneDot = euclidean.getPlaneDot( beforeSegment, removedSegment )
	afterPlaneDot = euclidean.getPlaneDot( removedSegment, afterSegment )
	if afterPlaneDot > beforePlaneDot:
		if removedSegmentLength > 0.8 * afterSegmentLength:
			return
		afterAlong = afterSegment.times( removedSegmentLength )
		afterBetween = beforePoint.plus( afterAlong )
		closestPath.insert( closestPointIndex + 1, afterBetween )
		return
	"""

def addPath( extrusionWidth, fill, path, rotationPlaneAngle ):
	"Add simplified path to fill."
	planeRotated = euclidean.getPathRoundZAxisByPlaneAngle( rotationPlaneAngle, euclidean.getSimplifiedLoop( path, extrusionWidth ) )
	fill.append( planeRotated )

def addSparseEndpoints( doubleExtrusionWidth, endpoints, fillDensity, fillLine, horizontalSegments, removedEndpoints, surroundingXIntersections ):
	"Add sparse endpoints."
	horizontalEndpoints = horizontalSegments[ fillLine ]
	for segment in horizontalEndpoints:
		addSparseEndpointsFromSegment( doubleExtrusionWidth, endpoints, fillDensity, fillLine, horizontalSegments, removedEndpoints, segment, surroundingXIntersections )

def addSparseEndpointsFromSegment( doubleExtrusionWidth, endpoints, fillDensity, fillLine, horizontalSegments, removedEndpoints, segment, surroundingXIntersections ):
	"Add sparse endpoints from a segment."
	endpointFirstPoint = segment[ 0 ].point
	endpointSecondPoint = segment[ 1 ].point
	shouldFill = fillLine < 1 or fillLine >= len( horizontalSegments ) - 1 or surroundingXIntersections == None
	if fillDensity > 0.0:
		if int( round( round( fillLine * fillDensity ) / fillDensity ) ) == fillLine:
			shouldFill = True
	if endpointFirstPoint.distance( endpointSecondPoint ) < doubleExtrusionWidth:
		shouldFill = True
	if shouldFill:
		endpoints += segment
		return
	if not isSegmentAround( horizontalSegments[ fillLine - 1 ], segment ):
		endpoints += segment
		return
	if not isSegmentAround( horizontalSegments[ fillLine + 1 ], segment ):
		endpoints += segment
		return
	for surroundingIndex in range( 0, len( surroundingXIntersections ), 2 ):
		surroundingXFirst = surroundingXIntersections[ surroundingIndex ]
		surroundingXSecond = surroundingXIntersections[ surroundingIndex + 1 ]
		if euclidean.isSegmentCompletelyInX( segment, surroundingXFirst, surroundingXSecond ):
			removedEndpoints += segment
			return
	endpoints += segment

def createFillForSurroundings( surroundingLoops ):
	"Create extra fill loops for surrounding loops."
	for surroundingLoop in surroundingLoops:
		createExtraFillLoops( surroundingLoop )

def createExtraFillLoops( surroundingLoop ):
	"Create extra fill loops."
	outsides = []
	insides = euclidean.getInsidesAddToOutsides( surroundingLoop.getLoopsToBeFilled(), outsides )
	allFillLoops = []
	for outside in outsides:
		transferredLoops = euclidean.getTransferredPaths( insides, outside )
		allFillLoops += getExtraFillLoops( transferredLoops, outside, surroundingLoop.extrusionWidth )
	if len( allFillLoops ) > 0:
		surroundingLoop.lastFillLoops = allFillLoops
	surroundingLoop.extraLoops += allFillLoops
	for innerSurrounding in surroundingLoop.innerSurroundings:
		createFillForSurroundings( innerSurrounding.innerSurroundings )

def fillChainFile( filename = '' ):
	"Fill the slices of a gcode file.  Chain slice the file if it is a GNU TriangulatedSurface file.  If no filename is specified, fill the first unmodified gcode file in this folder."
	if filename == '':
		unmodified = gcodec.getGNUGcode()
		if len( unmodified ) == 0:
			print >> sys.stderr, ( "There are no unmodified gcode files in this folder." )
			return
		filename = unmodified[ 0 ]
	startTime = time.time()
	fillPreferences = FillPreferences()
	preferences.readPreferences( fillPreferences )
	print >> sys.stderr, ( 'File ' + gcodec.getSummarizedFilename( filename ) + ' is being chain filled.' )
	gcodeText = gcodec.getFileText( filename )
	if gcodeText == '':
		return
	suffixFilename = filename[ : filename.rfind( '.' ) ] + '_fill.gcode'
	gcodec.writeFileText( suffixFilename, getFillChainGcode( gcodeText, fillPreferences ) )
	print >> sys.stderr, ( 'The filled file is saved as ' + suffixFilename )
	vectorwrite.writeSkeinforgeVectorFile( suffixFilename )
	print >> sys.stderr, ( 'It took ' + str( int( round( time.time() - startTime ) ) ) + ' seconds to fill the file.' )

def fillFile( filename = '' ):
	"Fill the slices of a gcode file.  If no filename is specified, fill the first unmodified gcode file in this folder."
	if filename == '':
		unmodified = gcodec.getUnmodifiedGCodeFiles()
		if len( unmodified ) == 0:
			print >> sys.stderr, ( "There are no unmodified gcode files in this folder." )
			return
		filename = unmodified[ 0 ]
	startTime = time.time()
	fillPreferences = FillPreferences()
	preferences.readPreferences( fillPreferences )
	print >> sys.stderr, ( 'File ' + gcodec.getSummarizedFilename( filename ) + ' is being filled.' )
	gcodeText = gcodec.getFileText( filename )
	if gcodeText == '':
		return
	suffixFilename = filename[ : filename.rfind( '.' ) ] + '_fill.gcode'
	gcodec.writeFileText( suffixFilename, getFillGcode( gcodeText, fillPreferences ) )
	print >> sys.stderr, ( 'The filled file is saved as ' + gcodec.getSummarizedFilename( suffixFilename ) )
	vectorwrite.writeSkeinforgeVectorFile( suffixFilename )
	print >> sys.stderr, ( 'It took ' + str( int( round( time.time() - startTime ) ) ) + ' seconds to fill the file.' )

def getExtraFillLoops( insideLoops, outsideLoop, radius ):
	"Get extra loops between inside and outside loops."
	slightlyGreaterThanRadius = 1.05 * radius
	tripleSlightlyGreaterThanRadius = 3.0 * slightlyGreaterThanRadius
	extraFillLoops = []
	circleNodes = intercircle.getCircleNodesFromLoop( outsideLoop, slightlyGreaterThanRadius )
	for inside in insideLoops:
		circleNodes += intercircle.getCircleNodesFromLoop( inside, slightlyGreaterThanRadius )
	centers = intercircle.getCentersFromCircleNodes( circleNodes )
	for center in centers:
		inset = intercircle.getInsetFromClockwiseLoop( center, radius )
		if euclidean.isWiddershins( center ) == euclidean.isWiddershins( inset ):
			if isPathAlwaysInsideLoop( outsideLoop, inset ):
				if isPathAlwaysOutsideLoops( insideLoops, inset ):
					if euclidean.getMaximumSpan( inset ) > tripleSlightlyGreaterThanRadius:
						extraFillLoops.append( inset )
	return extraFillLoops

def getFillChainGcode( gcodeText, fillPreferences = None ):
	"Fill the slices of a gcode text.  Chain fill the gcode if it is not already sliced."
	if not gcodec.isProcedureDone( gcodeText, 'slice' ):
		gcodeText = slice.getSliceGcode( gcodeText )
	return getFillGcode( gcodeText, fillPreferences )

def getFillGcode( gcodeText, fillPreferences = None ):
	"Fill the slices of a gcode text."
	if gcodeText == '':
		return ''
	if gcodec.isProcedureDone( gcodeText, 'fill' ):
		return gcodeText
	if fillPreferences == None:
		fillPreferences = FillPreferences()
		preferences.readPreferences( fillPreferences )
	skein = FillSkein()
	skein.parseGcode( fillPreferences, gcodeText )
	return skein.output.getvalue()

def getHorizontalSegments( fillLoops, alreadyFilledArounds, y ):
	"Get horizontal segments inside loops."
	solidXIntersectionList = []
	euclidean.addXIntersectionsFromLoops( fillLoops, - 1, solidXIntersectionList, y )
	for alreadyFilledAroundIndex in range( len( alreadyFilledArounds ) ):
		alreadyFilledLoops = alreadyFilledArounds[ alreadyFilledAroundIndex ]
		for alreadyFilledLoopIndex in range( len( alreadyFilledLoops ) ):
			alreadyFilledLoop = alreadyFilledLoops[ alreadyFilledLoopIndex ]
			euclidean.addXIntersections( alreadyFilledLoop, alreadyFilledAroundIndex, solidXIntersectionList, y )
	return euclidean.getSegmentsFromIntersections( solidXIntersectionList, y, fillLoops[ 0 ][ 0 ].z )

def getSurroundingXIntersections( alreadyFilledSize, doubleSolidSurfaceThickness, surroundingSlices, y ):
	"Get x intersections from surrounding layers."
	if len( surroundingSlices ) < doubleSolidSurfaceThickness:
		return None
	joinedX = []
	solidXIntersectionList = []
	for surroundingIndex in range( len( surroundingSlices ) ):
		surroundingSlice = surroundingSlices[ surroundingIndex ]
		euclidean.addXIntersectionsFromLoops( surroundingSlice, surroundingIndex, joinedX, y )
	solidTable = {}
	solid = False
	joinedX.sort( euclidean.compareSolidXByX )
	for solidX in joinedX:
		solidXYInteger = int( solidX.imag )
		euclidean.toggleHashtable( solidTable, solidXYInteger, "" )
		oldSolid = solid
		solid = len( solidTable ) >= doubleSolidSurfaceThickness
		if oldSolid != solid:
			solidXIntersectionList.append( solidX.real )
	return solidXIntersectionList

def getWithLeastLength( path, point ):
	"Insert a point into a path, at the index at which the path would be shortest."
	shortestPointIndex = None
	shortestPathLength = 999999999999999999.0
	for pointIndex in range( len( path ) + 1 ):
		concatenation = path[ : ]
		concatenation.insert( pointIndex, point )
		concatenationLength = euclidean.getPathLength( concatenation )
		if concatenationLength < shortestPathLength:
			shortestPathLength = concatenationLength
			shortestPointIndex = pointIndex
	return shortestPointIndex

def isIntersectingLoopPathList( loopList, otherPaths, pointBegin, pointEnd ):
	"Determine if the segment between the first and second point is intersecting the loop list."
	normalizedSegment = pointEnd.dropAxis( 2 ) - pointBegin.dropAxis( 2 )
	normalizedSegmentLength = abs( normalizedSegment )
	if normalizedSegmentLength == 0.0:
		return False
	normalizedSegment /= normalizedSegmentLength
	segmentYMirror = complex( normalizedSegment.real, - normalizedSegment.imag )
	pointBeginRotated = euclidean.getRoundZAxisByPlaneAngle( segmentYMirror, pointBegin )
	pointEndRotated = euclidean.getRoundZAxisByPlaneAngle( segmentYMirror, pointEnd )
	if euclidean.isLoopListIntersectingInsideXSegment( loopList, pointBeginRotated.x, pointEndRotated.x, segmentYMirror, pointBeginRotated.y ):
		return True
	for path in otherPaths:
		rotatedPath = euclidean.getPathRoundZAxisByPlaneAngle( segmentYMirror, path )
		for pointIndex in range( len( rotatedPath ) - 1 ):
			pointFirst = rotatedPath[ pointIndex ]
			pointSecond = rotatedPath[ pointIndex + 1 ]
			if euclidean.isLineIntersectingInsideXSegment( pointBeginRotated.x, pointEndRotated.x, pointFirst, pointSecond, pointBeginRotated.y ):
				return True
	return False

def isPathAlwaysInsideLoop( loop, path ):
	"Determine if all points of a path are inside another loop."
	for point in path:
		if euclidean.getNumberOfIntersectionsToLeft( point, loop ) % 2 == 0:
			return False
	return True

def isPathAlwaysOutsideLoops( loops, path ):
	"Determine if all points in a path are outside another loop in a list."
	for loop in loops:
		for point in path:
			if euclidean.getNumberOfIntersectionsToLeft( point, loop ) % 2 == 1:
				return False
	return True

def isSegmentAround( aroundSegments, segment ):
	"Determine if there is another segment around."
	for aroundSegment in aroundSegments:
		endpoint = aroundSegment[ 0 ]
		if isSegmentInX( segment, endpoint.point.x, endpoint.otherEndpoint.point.x ):
			return True
	return False

def isSegmentInX( segment, xFirst, xSecond ):
	"Determine if the segment overlaps within x."
	segmentFirstX = segment[ 0 ].point.x
	segmentSecondX = segment[ 1 ].point.x
	if min( segmentFirstX, segmentSecondX ) > max( xFirst, xSecond ):
		return False
	return max( segmentFirstX, segmentSecondX ) > min( xFirst, xSecond )

class FillSkein:
	"A class to fill a skein of extrusions."
	def __init__( self ):
		self.extruderActive = False
		self.lastExtraShells = - 1
		self.lineIndex = 0
		self.oldLocation = None
		self.oldOrderedLocation = Vec3()
		self.output = cStringIO.StringIO()
		self.rotatedLayer = None
		self.rotatedLayers = []
		self.shutdownLineIndex = sys.maxint
		self.thread = None

	def addFill( self, layerIndex ):
		"Add fill to the slice layer."
#		if layerIndex > 5:
#			return
		alreadyFilledArounds = []
		arounds = []
		back = - 999999999.0
		layerExtrusionWidth = self.extrusionWidth
		layerFillInset = self.fillInset
		layer = self.rotatedLayers[ layerIndex ].toBeginningLoops
		self.addLine( '(<layerStart> ' + str( layer[ 0 ][ 0 ].z ) + ' )' ) # Indicate that a new layer is starting.
		if self.rotatedLayers[ layerIndex ].rotation != None:
			layerExtrusionWidth = self.extrusionWidth * self.bridgeExtrusionWidthOverSolid
			layerFillInset = self.fillInset * self.bridgeExtrusionWidthOverSolid
			self.addLine( '(<bridgeLayer> )' ) # Indicate that this is a bridge layer.
		doubleExtrusionWidth = 2.0 * layerExtrusionWidth
		muchGreaterThanLayerFillInset = 3.0 * layerFillInset
		endpoints = []
		fill = []
		aroundInset = 0.7 * layerFillInset
		front = - back
		slightlyGreaterThanFill = 1.01 * layerFillInset
		layerRotationAroundZAngle = self.getLayerRoundZ( layerIndex )
		reverseRotationAroundZAngle = complex( layerRotationAroundZAngle.real, - layerRotationAroundZAngle.imag )
		rotatedExtruderLoops = []
		stretch = 0.5 * layerExtrusionWidth
		loops = []
		for thread in layer:
			loops.append( thread[ 1 : ] )
		surroundingSlices = []
		layerRemainder = layerIndex % int( round( self.fillPreferences.diaphragmPeriod.value ) )
		if layerRemainder >= int( round( self.fillPreferences.diaphragmThickness.value ) ):
			for surroundingIndex in range( 1, self.solidSurfaceThickness + 1 ):
				self.addRotatedSlice( layerIndex - surroundingIndex, reverseRotationAroundZAngle, surroundingSlices )
				self.addRotatedSlice( layerIndex + surroundingIndex, reverseRotationAroundZAngle, surroundingSlices )
		extraShells = self.fillPreferences.extraShellsSparseLayer.value
		if len( surroundingSlices ) < self.doubleSolidSurfaceThickness:
			if self.lastExtraShells != self.fillPreferences.extraShellsBase.value:
				extraShells = self.fillPreferences.extraShellsBase.value
		self.lastExtraShells = extraShells
		surroundingLoops = euclidean.getSurroundingLoops( layerExtrusionWidth, loops )
		for extraShellIndex in range( extraShells ):
			createFillForSurroundings( surroundingLoops )
		fillLoops = euclidean.getFillOfSurroundings( surroundingLoops )
		for loop in fillLoops:
			alreadyFilledLoop = []
			alreadyFilledArounds.append( alreadyFilledLoop )
			planeRotatedPerimeter = euclidean.getPathRoundZAxisByPlaneAngle( reverseRotationAroundZAngle, loop )
			rotatedExtruderLoops.append( planeRotatedPerimeter )
			circleNodes = intercircle.getCircleNodesFromLoop( planeRotatedPerimeter, slightlyGreaterThanFill )
			centers = intercircle.getCentersFromCircleNodes( circleNodes )
			for center in centers:
				alreadyFilledInset = intercircle.getInsetFromClockwiseLoop( center, layerFillInset )
#				if euclidean.isWiddershins( alreadyFilledInset ) == euclidean.isWiddershins( center ):
				if euclidean.getMaximumSpan( alreadyFilledInset ) > muchGreaterThanLayerFillInset or euclidean.isWiddershins( alreadyFilledInset ):
					alreadyFilledLoop.append( alreadyFilledInset )
				around = intercircle.getInsetFromClockwiseLoop( center, aroundInset )
				if euclidean.isPathInsideLoop( planeRotatedPerimeter, around ) != euclidean.isWiddershins( planeRotatedPerimeter ):
					arounds.append( around )
					for point in around:
						back = max( back, point.y )
						front = min( front, point.y )
		fillWidth = back - front
		numberOfIntervals = int( math.floor( fillWidth / layerExtrusionWidth ) )
		fillRemainder = fillWidth - float( numberOfIntervals ) * layerExtrusionWidth
		halfFillRemainder = 0.5 * fillRemainder
		back -= halfFillRemainder
		front += halfFillRemainder
		horizontalSegments = []
		for fillLine in range( numberOfIntervals + 1 ):
			y = front + float( fillLine ) * layerExtrusionWidth
			lineSegments = getHorizontalSegments( rotatedExtruderLoops, alreadyFilledArounds, y )
			horizontalSegments.append( lineSegments )
		removedEndpoints = []
		for fillLine in range( len( horizontalSegments ) ):
			y = front + float( fillLine ) * layerExtrusionWidth
			horizontalEndpoints = horizontalSegments[ fillLine ]
			surroundingXIntersections = getSurroundingXIntersections( len( alreadyFilledArounds ), self.doubleSolidSurfaceThickness, surroundingSlices, y )
			addSparseEndpoints( doubleExtrusionWidth, endpoints, self.fillDensity, fillLine, horizontalSegments, removedEndpoints, surroundingXIntersections )
		if len( endpoints ) < 1:
			euclidean.addToThreadsRemoveFromSurroundings( self.oldOrderedLocation, surroundingLoops, self )
			return
		stretchedXSegments = []
		for beginningEndpoint in endpoints[ : : 2 ]:
			beginningPoint = beginningEndpoint.point
			stretchedXSegment = StretchedXSegment().getFromXYStretch( beginningPoint.x, beginningPoint.y, beginningEndpoint.otherEndpoint.point.x, stretch )
			stretchedXSegments.append( stretchedXSegment )
		endpointFirst = endpoints[ 0 ]
		endpoints.remove( endpointFirst )
		otherEndpoint = endpointFirst.otherEndpoint
		endpoints.remove( otherEndpoint )
		nextEndpoint = None
		path = []
		paths = []
		if len( endpoints ) > 1:
			nextEndpoint = otherEndpoint.getNearestMiss( arounds, endpoints, layerExtrusionWidth, path, stretchedXSegments )
			if nextEndpoint != None:
				if nextEndpoint.point.distance2( endpointFirst.point ) < nextEndpoint.point.distance2( otherEndpoint.point ):
					endpointFirst = endpointFirst.otherEndpoint
					otherEndpoint = endpointFirst.otherEndpoint
		path.append( endpointFirst.point )
		path.append( otherEndpoint.point )
		while len( endpoints ) > 1:
			nextEndpoint = otherEndpoint.getNearestMiss( arounds, endpoints, layerExtrusionWidth, path, stretchedXSegments )
			if nextEndpoint == None:
				paths.append( path )
				path = []
				nextEndpoint = otherEndpoint.getNearestEndpoint( endpoints )
			path.append( nextEndpoint.point )
			endpoints.remove( nextEndpoint )
			if nextEndpoint.isOtherEndpointExtrudable( path ):
				otherEndpoint = nextEndpoint.otherEndpoint
				path.append( otherEndpoint.point )
				endpoints.remove( otherEndpoint )
			else:
				otherEndpoint = nextEndpoint
		paths.append( path )
		for removedEndpoint in removedEndpoints:
			addAroundClosest( arounds, layerExtrusionWidth, paths, removedEndpoint )
		for path in paths:
			addPath( layerFillInset, fill, path, layerRotationAroundZAngle )
		euclidean.transferPathsToSurroundingLoops( fill, surroundingLoops )
		euclidean.addToThreadsRemoveFromSurroundings( self.oldOrderedLocation, surroundingLoops, self )

	def addGcodeMovement( self, point ):
		"Add a movement to the output."
		self.lastOutputPoint = point
		self.output.write( "G1 X" + euclidean.getRoundedToThreePlaces( point.x ) + " Y" + euclidean.getRoundedToThreePlaces( point.y ) )
		self.addLine( " Z" + euclidean.getRoundedToThreePlaces( point.z ) + " F" + euclidean.getRoundedToThreePlaces( self.feedratePerMinute ) )

	def addGcodeFromGcodeThread( self, gcode, thread ):
		"Add a gcode thread to the output."
		if len( thread ) > 0:
			self.addGcodeMovement( thread[ 0 ] )
		else:
			print >> sys.stderr, ( "zero length vertex positions array which was skipped over, this should never happen" )
		if len( thread ) < 2:
			return
		self.addLine( gcode )
		for point in thread[ 1 : ]:
			self.addGcodeMovement( point )
		self.addLine( "M103" ) # Turn extruder off.

	def addLine( self, line ):
		"Add a line of text and a newline to the output."
		self.output.write( line + "\n" )

	def addRotatedSlice( self, layerIndex, reverseRotationAroundZAngle, surroundingSlices ):
		"Add a rotated slice to the surrounding slices."
		if layerIndex < 0 or layerIndex >= len( self.rotatedLayers ):
			return
		layer = self.rotatedLayers[ layerIndex ].toBeginningLoops
		rotatedSlice = []
		for thread in layer:
			planeRotatedLoop = euclidean.getPathRoundZAxisByPlaneAngle( reverseRotationAroundZAngle, thread[ 1 : ] )
			rotatedSlice.append( planeRotatedLoop )
		surroundingSlices.append( rotatedSlice )

	def addShutdownToOutput( self ):
		"Add shutdown gcode to the output."
		for line in self.lines[ self.shutdownLineIndex : ]:
			self.addLine( line )

	def addToThread( self, location ):
		"Add a location to thread."
		if self.oldLocation == None:
			return
		if self.thread == None:
			self.thread = [ self.oldLocation ]
			self.getRotatedLayer().toBeginningLoops.append( self.thread )
		self.thread.append( location )

	def getLayerRoundZ( self, layerIndex ):
		"Get the plane angle around z that the layer is rotated by."
		rotation = self.rotatedLayers[ layerIndex ].rotation
		if rotation != None:
			return rotation
		return euclidean.getPolar( self.fillBeginRotation + float( ( layerIndex % 2 ) * self.fillOddLayerExtraRotation ), 1.0 )

	def getRotatedLayer( self ):
		"Get the rotated layer, making a new one if necessary."
		if self.rotatedLayer == None:
			self.rotatedLayer = RotatedLayer()
			self.rotatedLayers.append( self.rotatedLayer )
		return self.rotatedLayer

	def linearMove( self, splitLine ):
		"Add a linear move to the thread."
		location = gcodec.getLocationFromSplitLine( self.oldLocation, splitLine )
		if self.extruderActive:
			self.addToThread( location )
		self.oldLocation = location

	def parseGcode( self, fillPreferences, gcodeText ):
		"Parse gcode text and store the bevel gcode."
		self.fillPreferences = fillPreferences
		self.lines = gcodec.getTextLines( gcodeText )
		self.parseInitialization()
		self.feedratePerMinute = 60.0 * fillPreferences.feedratePerSecond.value
		self.fillDensity = fillPreferences.fillDensity.value
		self.fillBeginRotation = math.radians( fillPreferences.fillBeginRotation.value )
		self.fillOddLayerExtraRotation = math.radians( fillPreferences.fillOddLayerExtraRotation.value )
		self.solidSurfaceThickness = int( round( self.fillPreferences.solidSurfaceThickness.value ) )
		self.doubleSolidSurfaceThickness = self.solidSurfaceThickness + self.solidSurfaceThickness
		for lineIndex in range( self.lineIndex, len( self.lines ) ):
			self.parseLine( lineIndex )
		for layerIndex in range( len( self.rotatedLayers ) ):
			self.addFill( layerIndex )
		self.addShutdownToOutput()

	def parseInitialization( self ):
		"Parse gcode initialization and store the parameters."
		for self.lineIndex in range( len( self.lines ) ):
			line = self.lines[ self.lineIndex ]
			splitLine = line.split( ' ' )
			firstWord = ''
			if len( splitLine ) > 0:
				firstWord = splitLine[ 0 ]
			if firstWord == '(<extrusionWidth>':
				self.extrusionWidth = float( splitLine[ 1 ] )
				self.fillInset = 0.5 * self.extrusionWidth * ( 2.0 - self.fillPreferences.infillPerimeterOverlap.value )
				self.addLine( '(<fillInset> ' + str( self.fillInset ) + ' )' ) # Set fill inset.
			elif firstWord == '(<bridgeExtrusionWidthOverSolid>':
				self.bridgeExtrusionWidthOverSolid = float( splitLine[ 1 ] )
			elif firstWord == '(<extrusionStart>':
				self.addLine( '(<procedureDone> fill )' )
				self.addLine( line )
				return
			self.addLine( line )

	def parseLine( self, lineIndex ):
		"Parse a gcode line and add it to the fill skein."
		splitLine = self.lines[ lineIndex ].split( ' ' )
		if len( splitLine ) < 1:
			return
		firstWord = splitLine[ 0 ]
		if firstWord == 'G1':
			self.linearMove( splitLine )
		elif firstWord == 'M101':
			self.extruderActive = True
		elif firstWord == 'M103':
			self.extruderActive = False
			self.thread = None
		elif firstWord == '(<layerStart>':
			self.rotatedLayer = None
			self.thread = None
		elif firstWord == '(<bridgeDirection>':
			secondWordWithoutBrackets = splitLine[ 1 ].replace( '(', '' ).replace( ')', '' )
			self.getRotatedLayer().rotation = complex( secondWordWithoutBrackets )
		elif firstWord == '(<extruderShutDown>':
			self.shutdownLineIndex = lineIndex

class FillPreferences:
	"A class to handle the fill preferences."
	def __init__( self ):
		"Set the default preferences, execute title & preferences filename."
		#Set the default preferences.
		self.diaphragmPeriod = preferences.IntPreference().getFromValue( 'Diaphragm Period (layers):', 29 )
		self.diaphragmThickness = preferences.IntPreference().getFromValue( 'Diaphragm Thickness (layers):', 3 )
		self.extraShellsBase = preferences.IntPreference().getFromValue( 'Extra Shells on Base (layers):', 0 )
		self.extraShellsSparseLayer = preferences.IntPreference().getFromValue( 'Extra Shells on Sparse Layer (layers):', 1 )
		self.feedratePerSecond = preferences.FloatPreference().getFromValue( 'Feedrate (mm/s):', 16.0 )
		self.filenameInput = preferences.Filename().getFromFilename( [ ( 'GNU Triangulated Surface text files', '*.gts' ), ( 'Gcode text files', '*.gcode' ) ], 'Open File to be Filled', '' )
		self.fillBeginRotation = preferences.FloatPreference().getFromValue( 'Fill Begin Rotation (degrees):', 45.0 )
		self.fillDensity = preferences.FloatPreference().getFromValue( 'Fill Density (ratio):', 0.5 )
		self.fillOddLayerExtraRotation = preferences.FloatPreference().getFromValue( 'Fill Odd Layer Extra Rotation (degrees):', 90.0 )
		self.infillPerimeterOverlap = preferences.FloatPreference().getFromValue( 'Infill Perimeter Overlap (ratio):', 0.5 )
		self.solidSurfaceThickness = preferences.IntPreference().getFromValue( 'Solid Surface Thickness (layers):', 3 )
		directoryRadio = []
		self.directoryPreference = preferences.RadioLabel().getFromRadioLabel( 'Fill All Unmodified Files in a Directory', 'File or Directory Choice:', directoryRadio, False )
		self.filePreference = preferences.Radio().getFromRadio( 'Fill File', directoryRadio, True )
		#Create the archive, title of the execute button, title of the dialog & preferences filename.
		self.archive = [
			self.diaphragmPeriod,
			self.diaphragmThickness,
			self.extraShellsBase,
			self.extraShellsSparseLayer,
			self.feedratePerSecond,
			self.filenameInput,
			self.fillBeginRotation,
			self.fillDensity,
			self.fillOddLayerExtraRotation,
			self.infillPerimeterOverlap,
			self.solidSurfaceThickness,
			self.directoryPreference,
			self.filePreference ]
		self.executeTitle = 'Fill'
#		self.filename = getPreferencesFilePath( 'fill.csv' )
		self.filenamePreferences = 'fill.csv'
		self.filenameHelp = 'fill.html'
		self.title = 'Fill Preferences'

	def execute( self ):
		"Fill button has been clicked."
		filenames = gcodec.getGcodeDirectoryOrFile( self.directoryPreference.value, self.filenameInput.value, self.filenameInput.wasCancelled )
		for filename in filenames:
			fillChainFile( filename )


class RotatedLayer:
	"A rotated layer."
	def __init__( self ):
		"RotatedLayer constructor."
		self.rotation = None
		self.toBeginningLoops = []

	def __repr__( self ):
		"Get the string representation of this RotatedLayer."
		return str( self.rotation ) + ' ' + str( self.toBeginningLoops )


class StretchedXSegment:
	"A stretched x segment."
	def __repr__( self ):
		"Get the string representation of this StretchedXSegment."
		return str( self.xMinimum ) + ' ' + str( self.xMaximum ) + ' ' + str( self.y )

	def getFromXYStretch( self, firstX, y, secondX, stretch ):
		"Initialize from x, y, and stretch."
		self.xMaximum = max( firstX, secondX ) + stretch
		self.xMinimum = min( firstX, secondX ) - stretch
		self.y = y
		return self


def main( hashtable = None ):
	"Display the fill dialog."
	preferences.displayDialog( FillPreferences() )

if __name__ == "__main__":
	main()
